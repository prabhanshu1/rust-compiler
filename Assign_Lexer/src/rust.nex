/abstract|alignof|as|become|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|offsetof|override|priv|proc|pub|pure|ref|return|Self|self|sizeof|static|struct|super|trait|true|type|typeof|unsafe|unsized|use|virtual|where|while|yield|println|macro_rules/  { 
lval.s = txt(); return KEYWORD }
/i8|i16|i32|i64|isize|u8|u16|u32|u64|usize|f32|f64|char|bool/ {lval.s = txt(); return VAR_TYPE}
/=[\-\+]?[0-9]+/          { lval.n,_ = strconv.ParseInt(txt()[1:], 10, 64); return OPEQ_INTEGER}
/[0-9]+/          { lval.n,_ = strconv.ParseInt(txt(), 10, 64); return INTEGER }
/0x[0-9a-f]+/          { lval.s =txt() return HEX }
/0o[0-7]+/          { lval.s =txt() return OCTAL }
/0b[0-1]+/          { lval.s =txt() return BINARY }
/=[\-\+]?[0-9]+\.?[0-9]+([eE][-+]?[0-9]+)?/ { lval.n,_ = strconv.ParseFloat(txt()[1:], 64); return OPEQ_FLOAT }
/[0-9]+\.?[0-9]+([eE][-+]?[0-9]+)?/ { lval.n,_ = strconv.ParseFloat(txt(), 64); return FLOAT }
/[\n]/ {line++}
/[ \t]+/        { /* eat up whitespace */ }
/(\/\*([^\*]|[\r\n]|(\*+([^\*\/]|[\r\n])))*\*+\/)|(\/\/[^\n]*)/        { /* eat up comments */ }
/(\"([^\"])*\")|(\'([^\'])\')/        { lval.s =txt(); return LITERAL }
/\>\>/ { return OP_RSHIFT }
/\<\</ { return OP_LSHIFT }
/\+\=/ { return OP_ADDEQ }
/\-\=/ { return OP_SUBEQ }
/\*\=/ { return OP_MULEQ }
/\/\=/ { return OP_DIVEQ }
/\%\=/ { return OP_MODEQ }
/\-\>/ { return OP_INSIDE }
/\=\=/ { return OP_EQEQ }
/\!\=/ { return OP_NOTEQ }
/\&\&/ { return OP_ANDAND }
/\|\|/ { return OP_OROR }
/\*\*/ { return OP_POWER }
/\.\./ { return OP_DOTDOT }

/\-/ { return OP_SUB }
/\+/ { return OP_ADD }
/\&/ { return OP_AND }
/\|/ { return OP_OR }
/\^/ { return OP_XOR }
/\// { return OP_FSLASH }
/\!/ { return OP_NOT }
/\:/ { return OP_COLUMN }
/\*/ { return OP_MUL }
/\>/ { return OP_GTHAN }
/\</ { return OP_LTHAN }
/\%/ { return OP_MOD }
/\=/ { return OP_EQ }
/\./ { return OP_DOT }
/\'/ { return OP_APOSTROPHE }

/::/ { return SYM_COLCOL }
/\#/ { return SYM_HASH }
/\[/ { return SYM_OPEN_SQ }
/\]/ { return SYM_CLOSE_SQ }
/\(/ { return SYM_OPEN_ROUND }
/\)/ { return SYM_CLOSE_ROUND }
/\{/ { return SYM_OPEN_CURLY }
/\}/ { return SYM_CLOSE_CURLY }
/\,/ { return SYM_COMMA }
/\;/ { return SYM_SEMCOL }
/[\_a-zA-Z][\_a-zA-Z0-9]*/ {lval.s =txt(); return IDENTIFIER}
/\*\// {fmt.Println("Syntax Error \n","at line number\n",txt(),"is not a valid syntax\n",line+1); return;}
/[0-9]+[\_a-zA-Z]+[\_a-zA-Z0-9]*/ {fmt.Println("Syntax Error \n","at line number\n",txt(),"is not a valid syntax\n",line+1); return;}
/./ {fmt.Println("Syntax Error \n","at line number\n",txt(),"is not a valid syntax\n",line+1); return;}
//
package main
import ("fmt";"os";"sort";"log")
func main() {
  line := 0

  in,err := os.Open(os.Args[1])
  if err != nil {
          log.Fatal(err)
  }

  lex := NewLexer(in)
  txt := func() string { return lex.Text() }
  NN_FUN(lex)


}

