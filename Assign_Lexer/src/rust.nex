\abstract/ { return ABSTRACT}	\alignof/ { return ALIGNOF}	\as/ { return AS}	\become/ { return BECOME}	\box/ { return BOX}	\break/ { return BREAK}	\const/ { return CONST}	\continue/ { return CONTINUE}	\crate/ { return CRATE}	\do/ { return DO}	\else/ { return ELSE}	\enum/ { return ENUM}	\extern/ { return EXTERN}	\false/ { return FALSE}	\final/ { return FINAL}	\fn/ { return FN}	\for/ { return FOR}	\if/ { return IF}	\impl/ { return IMPL}	\in/ { return IN}	\let/ { return LET}	\loop/ { return LOOP}	\macro/ { return MACRO}	\match/ { return MATCH}	\mod/ { return MOD}	\move/ { return MOVE}	\mut/ { return MUT}	\offsetof/ { return OFFSETOF}	\override/ { return OVERRIDE}	\priv/ { return PRIV}	\proc/ { return PROC}	\pub/ { return PUB}	\pure/ { return PURE}	\ref/ { return REF}	\return/ { return RETURN}	\Self/ { return SELF}	\self/ { return SELF}	\sizeof/ { return SIZEOF}	\static/ { return STATIC}	\struct/ { return STRUCT}	\super/ { return SUPER}	\trait/ { return TRAIT}	\true/ { return TRUE}	\type/ { return TYPE}	\typeof/ { return TYPEOF}	\unsafe/ { return UNSAFE}	\unsized/ { return UNSIZED}	\use/ { return USE}	\virtual/ { return VIRTUAL}	\where/ { return WHERE}	\while/ { return WHILE}	\yield/ { return YIELD}	\println/ { return PRINTLN}	\macro_rules!/ { return MACRO_RULES}	

/i8|i16|i32|i64|isize|u8|u16|u32|u64|usize|f32|f64|char|bool/ {lval.s = yylex.Text(); return VAR_TYPE}
/=[\-\+]?[0-9]+/          { lval.n64,_ = strconv.ParseInt(yylex.Text()[1:], 10, 64); return OPEQ_INTEGER}
/[0-9]+/          { lval.n64,_ = strconv.ParseInt(yylex.Text(), 10, 64);  return INTEGER }
/0x[0-9a-f]+/          { lval.n64,_ =strconv.ParseInt(yylex.Text(), 16, 64); return INTEGER }
/0o[0-7]+/          { lval.n64,_ =strconv.ParseInt(yylex.Text(), 8, 64); return INTEGER }
/0b[0-1]+/          { lval.n64,_ =strconv.ParseInt(yylex.Text(), 2, 64); return INTEGER }
/=[\-\+]?[0-9]+\.?[0-9]+([eE][-+]?[0-9]+)?/ { lval.f64,_ = strconv.ParseFloat(yylex.Text()[1:], 64); return OPEQ_FLOAT }
/[0-9]+\.?[0-9]+([eE][-+]?[0-9]+)?/ { lval.f64,_ = strconv.ParseFloat(yylex.Text(), 64); return FLOAT }
/[\n]/ {line++; return NEWLINE}
/[ \t]+/        { return NEWLINE/* eat up whitespace */ }
/(\/\*([^\*]|[\r\n]|(\*+([^\*\/]|[\r\n])))*\*+\/)|(\/\/[^\n]*)/        { return NEWLINE/* eat up comments */ }
/(\"([^\"])*\")|(\'([^\'])\')/        { lval.s =yylex.Text(); return LITERAL }
/\>\>/ { return OP_RSHIFT }
/\<\</ { return OP_LSHIFT }
/\+\=/ { return OP_ADDEQ }
/\-\=/ { return OP_SUBEQ }
/\*\=/ { return OP_MULEQ }
/\/\=/ { return OP_DIVEQ }
/\%\=/ { return OP_MODEQ }
/\-\>/ { return OP_INSIDE }
/\=\>/ { return OP_FAT_ARROW }
/\=\=/ { return OP_EQEQ }
/\!\=/ { return OP_NOTEQ }
/\&\&/ { return OP_ANDAND }
/\|\|/ { return OP_OROR }
/\*\*/ { return OP_POWER }
/\.\./ { return OP_DOTDOT }

/\-/ { return OP_SUB }
/\+/ { return OP_ADD }
/\&/ { return OP_AND }
/\|/ { return OP_OR }
/\^/ { return OP_XOR }
/\// { return OP_FSLASH }
/\!/ { return OP_NOT }
/\:/ { return OP_COLUMN }
/\*/ { return OP_MUL }
/\>/ { return OP_GTHAN }
/\</ { return OP_LTHAN }
/\%/ { return OP_MOD }
/\=/ { return OP_EQ }
/\./ { return OP_DOT }
/\'/ { return OP_APOSTROPHE }

/::/ { return SYM_COLCOL }
/\#/ { return SYM_HASH }
/\[/ { return SYM_OPEN_SQ }
/\]/ { return SYM_CLOSE_SQ }
/\(/ { return SYM_OPEN_ROUND }
/\)/ { return SYM_CLOSE_ROUND }
/\{/ { return SYM_OPEN_CURLY }
/\}/ { return SYM_CLOSE_CURLY }
/\,/ { return SYM_COMMA }
/\;/ { return SYM_SEMCOL }
/[\_a-zA-Z][\_a-zA-Z0-9]*/ {lval.s =yylex.Text(); return IDENTIFIER}
/[\_a-zA-Z][\_a-zA-Z0-9]*!/ {lval.s =yylex.Text(); return MACRO}
/\*\// {fmt.Println("Syntax Error \n","at line number\n",yylex.Text(),"is not a valid syntax\n",line+1); return NEWLINE;}
/[0-9]+[\_a-zA-Z]+[\_a-zA-Z0-9]*/ {fmt.Println("Syntax Error \n","at line number\n",yylex.Text(),"is not a valid syntax\n",line+1); return NEWLINE;}
/./ {fmt.Println("Syntax Error \n","at line number\n",yylex.Text(),"is not a valid syntax\n",line+1); return NEWLINE;}
//
package main
import ("fmt";"os";"strconv";)
func main() {


/*  in,err := os.Open(os.Args[1])
  if err != nil {
          log.Fatal(err)
  }
*/
  yyParse(NewLexer(os.Stdin))


}

